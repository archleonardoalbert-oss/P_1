Dominio:
    Mi proyecto se centra en la administración de los eventos de un Hotel que llamamos LuxAlbert, basícamente puedes crear y eliminar eventos,
    cada evento tiene unos recursos que necesita sí o sí para funcionar, luego hablaremos más a detalle de eso, pero además de administrar los 
    eventos del hotel también podrás administrar los recursos de este creándolos, eliminándolos (si no están protegidos) y modificándolos, la página
    además te permite visualizar los eventos que has creado y ver los detalles del mismo

Eventos:
    Los eventos los creé utilizando un poco de POO, utilicé clases abstractas para una clase Event más genérica (DRY) aunque realmente no 
    aproveché demasiado esta implementación puesto que los eventos son básicamente un objeto con atributos, sin métodos definidos excepto
    __repr__ que lo implementé principalmente para facilitar el Debug aunque no lo he utilizado, igual pienso que el hecho de haber utilizado
    POO en el apartado de eventos no aporta demasiado pero tampoco le quita, de hecho creo que hace el proyecto mucho más escalable


Validación:
    Para validar o no la creación de un evento creé la clase Validation, la cual tiene varios métodos que se encargan de partes concretas de esta 
    validación, por ejemplo hay un método para validar fechas (que estén escritas en el formato que espero y que sean válidas), para verificar que
    el evento tenga los recursos mínimos que se definió para que funcionara, etc, el return de cada uno de estos métodos es uno de dos:
    es o un valor booleano indicando que se validó o no ese aspecto del evento o una tupla (bool, list) que basícamente me permite en caso de que
    ese aspecto a validar del evento haya fallado tener más detalles de por qué falló, dichos detalles se guardan en la lista dentro de la tupla,
    por ejemplo, en caso de que el evento necesite 'mesas' y el usuario no las haya puesto el return de Check_min_resources sería: *(False, ['mesas])*,
    posteriormente toda esta información la utilizo para mostrarle un mensaje al usuario de por qué no se pudo crear su evento en caso de que haya
    fallado algo (realmente creo que el formato de este mensaje de error se puede mejorar bastante, aunque así está bien)

    Nota: he cambiado el campo de entrada de la fecha del usuario a uno más profesional, impidiendo que el usuario introduzca una fecha imposible, 
    de igual forma dejaré la validación de la fecha, además, la verificación de que el intervalo sea válido sigue teniendo sentido


Dependencia y Colisión de recursos:
    En el proyecto estos conceptos están implementados de la siguiente manera:
    En Database.json puedes ver unas claves llamadas 'collitions' y 'depn_resources', el valor asociado a estas claves son 2 diccionarios que contienen
    básicamente la información de qué recursos necesitan de cuáles para poder ser utilizados y qué recursos no pueden estar con cuáles para ser 
    utilizados, se decidió agregar estos aspectos aparentemente estáticos del backend de la web a la base de datos para darle al usuario la oportunidad
    de modificarlos y que la experiencia administrando el hotel sea más completa y personalizada. Además internamente hay implementado un mecanismo de
    verificación que te impide crear o modificar un recurso para que este tenga un mismo recurso en sus colisiones y en sus dependencias


Visualización de eventos:
    Para enriquecer la experiencia se decidió utilizar para visualizar los eventos que ya se han creado streamlit_calendar, principalmente se decidió
    hacerlo de esta manera por:
    (1) estamos creando una pagina en streamlit_calendar
    (2) por la afinidad que tiene la visualización de eventos en streamlit_calendar con la manera que teníamos de guardar los eventos en nuestra base 
        de datos
    Además de eso, la parte de visualizar los detalles de los eventos se implementó de la siguiente manera:
    Luego de la visualización del calendario se crean 2 columnas, la izquierda para tener una tabla de todos los eventos que hay activos en el momento
    y la derecha para al seleccionar uno de estos eventos que te muestre toda su información, para crear las tablas primero creamos los data_frames con pandas,
    estos data frames solamente tienen el nombre, el color, la fecha y el id del evento, luego para el lado izquierdo se crea un 'data_frame_plus' que es como para
    ponerle por encima del dataframe una capa de CSS para poder visualizar en la casilla del color del evento el color en sí y no solamente el código del color, ej '#00FF00'
    ademas tambien implementa un rerun en la web al tocar cada la tabla en si, luego del lado derecho cuando tocas una fila concreta de la tabla se crea un nuevo data frame
    aprovechando que obtuvimos al informacion del id del evento para saber exactamente cual evento es e ir a la base de datos (los eventos concretamente) y extraer los recursos y 
    las dependecnias del mismo, agregarlas al data frame y ahora si crear la tabla, este data frame no esta estilizado, por eso se ven los codigos de los colores en vez 
    de los colores en si


Administracion de recursos:
    A la hora de validar un evento un aspecto fundamental es saber si de los recursos que exige el usuario para su evento hay al menos una unidad de cada uno, esto se hace de la 
    siguiente manera:
    primero el usuario ingresa los recursos que quiere para su evento, la fecha de inicio de este y la fecha de fin (esta infromacion es suficiente para esta validacion), luego
    con esta informacion la instancia de la clase Validation lo que hace es cargar todos los eventos de la base de datos y todos los recursos disponibles de la base de datos y basicamente
    lo que se hace es recorrer todos los eventos con un for verificando si se cumple la condicion de que el intervalo del evento que stoy intentando crear tiene alguna colicion con el intervalo
    del evento de la iteracion actual, de ser asi se regresa a la copia del diccionario de los recursos que descargue y se le restan todos los recursos que tiene programados el evento de la iteracion
    actual, esto se repite hasta que no queden mas eventos, luego se verifica si en los recursos que quedaron hay los suficientes recursos como para crear el evento.
    POTENCIAL MEJORA: Seria muy buneo ordrnar la lista de eventos por el intervalo de ocurrecnia de cada uno (se podria sacar un promedio de la fecha para tener un valor puntual en la linea 
    temporal) y luego hacer una busqueda binaria para encontrar la familia de eventos que tienen alguna interseccion con el intervalo de ocurrencia de mi evento, de esta forma se optimizaria mucho
    el tiempo de validacion de este aspecto


Recomendacion inteligente de fecha:
    La recomendacion inteligente de fechas funciona de la siguiente manera: 
    Si en la creacion de tu evento fallo unicamente la disponibilidad de lso recursos en la fecha que lo quieres crear basicamente se utiliza + timedelta(days= 1) para mover en un dia el inicio
    del intervalo y el fin del mosmo manteniendo la duracion del intervalor, leugo se intenta nuevamente crear el evento y si falla se repite el proceso hasta que no falle, en cuyo caso se 
    habra encontrado la fecha a recomendar
    POTENCIAL MEJORA: si los eventos estubieran ordenados por fecha como se menciona arriba se pudiera buscar un 'hueco' entre los eventos midiendo los saltos desde el fin del intervalo del evento
    en el indice i hasta el inicio del intervalo del evento en el indici i + 1, de esta manera si este 'hueco' es mayor al intervalo del evento se puede recomendaar directamente colocar el evento
    ahi (aunque perderia cercania con la fecha preferida por el ususario)


Eliminar evento:
    La eliminacion de los eventos se hace por el ID del mismo


Info de la pagina:
    La seccion de Info de la pagina la creare completamente con la IA (cosa que no he hecho con ninguna otra parte de mi proyecto) ya que creo que tambien es importante demostrar que el trabajo 
    secundario se le puede descargar a la IA (si sabes lo que haces) sin afectar el curso que definiste para tu proyecto


ASPECTOS A MEJORAR:
    1) El proyecto puede tener una mejora sustancial con respecto a la eficiencia, puesto que carga los datos de la base de datos demaciadas veces, esta esta mal 
       ordenada, esto ultimo hace que tenga que analizar muchos mas datos de lo normal para obtener la informacion que quiero para por ejemplo validar un evento,
       eso mezclado con la innecesaria cantidad de veces que cargo grandes secciones de la base de datos hacen que el rendimiento se vea grandemente golpeado

    2) Con respecto al codigo, puedo y quizas lo haga implementar una mayor modularizacion, evitando codigos extremadamente largos y poco legibles, haciendo la aplicacion
       en si mucho mas facil de depurar, ademas podria aumentar fuertemente la presencia de OOP haciendo mi proyecto considerablemente mas escalable